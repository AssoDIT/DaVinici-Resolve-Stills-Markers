#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# MIT License
#
# Copyright (c) 2023 Roger Magnusson
# Translated to python by Bryan Randell
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# -----------------------------------------------------------------------------
#
#   A script that allows you to grab stills from timeline markers and optionally export them to a folder.
#
#   To use the script, copy it to the "Workflow Integration Plugins" folder (or create it) and restart Resolve.
#   Mac OS X:
#     "/Library/Application Support/Blackmagic Design/DaVinci Resolve/Workflow Integration Plugins/"
#   Windows:
#     "%PROGRAMDATA%\Blackmagic Design\DaVinci Resolve\Support\Workflow Integration Plugins\"
#
# Added features
# - Rename stills with metadata from clip scene/shot/take/camera or if not available clip name, but
# only if  "Use labels on still export" is checked in Resolve's gallery still album.
# - Resize exported stills to a percentage of the original size and resize timeline if resize is more than 100 percent.
# - Grab stills only between in and out points.
# - Remove drx files generated by Resolve.
# - Export stills to a folder with the same name as the timeline.
# - Compress exported images with ImageOptim if installed.
#
# Fixes (macOS)
# - No more double GrabStill when Burnins is enabled.
# - DRX removal works in both batch export and burnin mode.
# - Burnin font: use a real TTF/TTC on macOS with a larger default size.

import os
import subprocess
import sys, time
import json
from datetime import datetime

try:
    from PIL import Image, ImageDraw, ImageFont
    print("Pillow is already installed.")
except ImportError:
    print("Pillow not found. Installing...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "Pillow"])
    from PIL import Image, ImageDraw, ImageFont


class SMPTE(object):
    # Converts frames to SMPTE timecode of arbitrary frame rate and back.
    # Copyright 2021, Igor Riđanović, Igor@hdhead.com, Meta Fide
    """Frames to SMPTE timecode converter and reverse."""

    def __init__(self):
        self.fps = 24
        self.df = False

    def getframes(self, tc):
        """Converts SMPTE timecode to frame count."""

        if int(tc[9:]) > self.fps:
            raise ValueError("SMPTE timecode to frame rate mismatch.", tc, self.fps)

        hours = int(tc[:2])
        minutes = int(tc[3:5])
        seconds = int(tc[6:8])
        frames = int(tc[9:])

        totalMinutes = int(60 * hours + minutes)

        # Drop frame calculation using the Duncan/Heidelberger method.
        if self.df:
            dropFrames = int(round(self.fps * 0.066666))
            timeBase = int(round(self.fps))

            hourFrames = int(timeBase * 60 * 60)
            minuteFrames = int(timeBase * 60)

            frm = int(
                ((hourFrames * hours) + (minuteFrames * minutes) + (timeBase * seconds) + frames)
                - (dropFrames * (totalMinutes - (totalMinutes // 10)))
            )
        else:
            self.fps = int(round(self.fps))
            frm = int((totalMinutes * 60 + seconds) * self.fps + frames)

        return frm

    def gettc(self, frames):
        """Converts frame count to SMPTE timecode."""

        frames = abs(frames)

        if self.df:
            spacer = ":"
            spacer2 = ":"

            dropFrames = int(round(self.fps * 0.066666))
            framesPerHour = int(round(self.fps * 3600))
            framesPer24Hours = framesPerHour * 24
            framesPer10Minutes = int(round(self.fps * 600))
            framesPerMinute = int(round(self.fps) * 60 - dropFrames)

            frames = frames % framesPer24Hours

            d = frames // framesPer10Minutes
            m = frames % framesPer10Minutes

            if m > dropFrames:
                frames = frames + (dropFrames * 9 * d) + dropFrames * ((m - dropFrames) // framesPerMinute)
            else:
                frames = frames + dropFrames * 9 * d

            frRound = int(round(self.fps))
            hr = int(frames // frRound // 60 // 60)
            mn = int((frames // frRound // 60) % 60)
            sc = int((frames // frRound) % 60)
            fr = int(frames % frRound)
        else:
            self.fps = int(round(self.fps))
            spacer = ":"
            spacer2 = spacer

            frHour = self.fps * 3600
            frMin = self.fps * 60

            hr = int(frames // frHour)
            mn = int((frames - hr * frHour) // frMin)
            sc = int((frames - hr * frHour - mn * frMin) // self.fps)
            fr = int(round(frames - hr * frHour - mn * frMin - sc * self.fps))

        return (
            str(hr).zfill(2)
            + spacer
            + str(mn).zfill(2)
            + spacer
            + str(sc).zfill(2)
            + spacer2
            + str(fr).zfill(2)
        )


def detect_system_and_image_optim_installed(app_name="ImageOptim"):
    return (sys.platform == "darwin") and os.path.exists(f"/Applications/{app_name}.app")


def load_settings_from_json(
    settings: dict,
    setting_sub_folder_name: str = "Stills_Marker_python_settings",
    setting_file_name: str = "settings.json",
):
    script_path = os.path.dirname(os.path.abspath(sys.argv[0]))
    setting_path_folder = os.path.join(script_path, setting_sub_folder_name)
    if not os.path.exists(setting_path_folder):
        os.mkdir(setting_path_folder)

    setting_path = os.path.join(setting_path_folder, setting_file_name)

    try:
        with open(setting_path) as j:
            json_settings = json.load(j)
        print(f"loaded settings from {setting_path}")

        merged = dict(settings)
        for k in merged.keys():
            if k in json_settings:
                merged[k] = json_settings[k]

        with open(setting_path, "w") as j:
            json.dump(merged, j)

        return merged

    except:
        print("cannot find setting file")
        with open(setting_path, "w") as j:
            json.dump(settings, j)
        print(f"created a {setting_path} setting file")
        return settings


def save_settings_to_json(
    settings: dict,
    setting_sub_folder_name: str = "Stills_Marker_python_settings",
    setting_file_name: str = "settings.json",
):
    try:
        script_path = os.path.dirname(os.path.abspath(sys.argv[0]))
        setting_path_folder = os.path.join(script_path, setting_sub_folder_name)
        setting_path = os.path.join(setting_path_folder, setting_file_name)

        with open(setting_path, "w") as j:
            json.dump(settings, j)
    except:
        print("cannot find setting file")


# --------------------------------------------------------------------------
# Load burnin config from web UI if present
def load_burnin_web_settings(setting_sub_folder_name="Stills_Marker_python_settings",
                             burnin_file_name="burnin_web_settings.json"):
    """
    Loads burnin configuration generated by external web UI.
    Returns dict if found, otherwise empty dict.
    """
    try:
        script_path = os.path.dirname(os.path.abspath(sys.argv[0]))
        setting_path_folder = os.path.join(script_path, setting_sub_folder_name)
        burnin_path = os.path.join(setting_path_folder, burnin_file_name)

        if os.path.exists(burnin_path):
            with open(burnin_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            print(f"Loaded burnin web settings from {burnin_path}")
            return data if isinstance(data, dict) else {}
    except Exception as e:
        print(f"Could not load burnin web settings: {e}")

    return {}


def reselect_album(album, gallery):
    for gallery_album in gallery.GetGalleryStillAlbums():
        if gallery_album != album:
            gallery.SetCurrentStillAlbum(gallery_album)
            break
    gallery.SetCurrentStillAlbum(album)
    return album


def change_page(page):
    current_page = resolve.GetCurrentPage()

    def get_state():
        current_state = {
            "page": current_page,
            "project": resolve.GetProjectManager().GetCurrentProject(),
        }

        if current_state["project"]:
            current_state["timeline"] = current_state["project"].GetCurrentTimeline()

            if current_state["timeline"]:
                current_state["timecode"] = current_state["timeline"].GetCurrentTimecode()

        return current_state

    if current_page in ["media", "fusion"]:
        assert resolve.OpenPage(page), f"Couldn't open page: {page}"
        state = get_state()
    else:
        state = get_state()
        assert resolve.OpenPage(page), f"Couldn't open page: {page}"

    return state


def restore_page(state):
    def set_state(initial_state):
        current_project = resolve.GetProjectManager().GetCurrentProject()

        if current_project:
            current_timeline = current_project.GetCurrentTimeline()

            if current_timeline and current_timeline == initial_state["timeline"] and initial_state["timecode"]:
                initial_state["timeline"].SetCurrentTimecode(initial_state["timecode"])

    current_page = resolve.GetCurrentPage()

    if current_page in ["media", "fusion"]:
        resolve.OpenPage(state["page"])
        set_state(state)
    else:
        set_state(state)
        resolve.OpenPage(state["page"])


def timecode_from_frame(frame, frame_rate, drop_frame):
    smpte = SMPTE()
    smpte.fps = frame_rate
    smpte.df = drop_frame
    return smpte.gettc(frame)


def frame_from_timecode(timecode, frame_rate, drop_frame):
    smpte = SMPTE()
    smpte.fps = frame_rate
    smpte.df = drop_frame
    return smpte.getframes(timecode)


def create_new_filename(clip, format_style="EU", fallback_shot_from_scene=True):
    """
    format_style:
        "US" -> Scene_Shot-Take_Camera_Clipname
        "EU" -> Scene_Shot_Take_Camera_Clipname
    """
    props = clip.GetMediaPoolItem().GetClipProperty()

    scene_raw = (props.get("Scene") or "").strip()
    shot = (props.get("Shot") or "").strip()
    take = (props.get("Take") or "").strip()
    clipname = (clip.GetName() or "").split(".")[0]

    letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    scene = ""
    camera = ""
    parts = []

    if scene_raw:
        sep = (settings.get("rename_scene_shot_separator", "/") if isinstance(settings, dict) else "/")
        sep = (sep or "/").strip()

        if fallback_shot_from_scene and sep and (sep in scene_raw) and (not shot):
            scene, shot = scene_raw.split(sep, 1)
        else:
            scene = "".join(c for c in scene_raw if c.isdigit())
            if fallback_shot_from_scene and not shot:
                shot = "".join(c for c in scene_raw if c in letters)

    name = clip.GetName() or ""

    if len(name) >= 2 and name[0] == "A" and name[1] == "A":
        camera = ""
    elif len(name) >= 1 and name[0] in letters:
        camera = name[0]

    if scene:
        base = scene
        if shot:
            base += f"_{shot}"
        if take:
            base += f"-{take}" if format_style == "US" else f"_{take}"
        parts.append(base)

    if camera:
        parts.append(camera)

    parts.append(clipname)

    return "_".join(parts)


def resize_image(input_path, percentage, delete_original, original_size=None):
    if percentage > 1 and percentage < 100:
        with Image.open(input_path) as img:
            new_width = int(img.width * percentage / 100)
            new_height = int(img.height * percentage / 100)

            resized_img = img.resize((new_width, new_height), Image.LANCZOS)
            if delete_original:
                resized_img.save(input_path)
            else:
                input_path_split, extension = os.path.splitext(input_path)
                output_path = f"{input_path_split}_resized{extension}"
                resized_img.save(output_path)
    else:
        if original_size and not delete_original:
            with Image.open(input_path) as img:
                resized_img = img.resize((original_size[0], original_size[1]), Image.LANCZOS)
                input_path_split, extension = os.path.splitext(input_path)
                output_path = f"{input_path_split}_original_size{extension}"
                resized_img.save(output_path)
        else:
            print("bypass downsizing, percentage must be between 1 and 100.")


def get_all_mediapool_bins(parent_bin):
    bins_list = [b for b in parent_bin.GetSubFolderList()]
    for sub_bin in list(bins_list):
        bins_list.extend(get_all_mediapool_bins(sub_bin))
    return bins_list


def find_in_out_points_of_timeline_in_folder(root_folder, timeline):
    bins_list = get_all_mediapool_bins(root_folder)
    bins_list.extend([root_folder])

    for b in bins_list:
        for item in b.GetClipList():
            if item.GetClipProperty()["Type"] == "Timeline" and item.GetName() == timeline.GetName():
                markIn = item.GetClipProperty("In") or item.GetClipProperty("Start TC")
                markOut = item.GetClipProperty("Out") or item.GetClipProperty("End TC")
                return markIn, markOut
    return "", ""


def detect_in_out_point_timeline(project, timeline):
    root_folder = project.GetMediaPool().GetRootFolder()
    markIn, markOut = find_in_out_points_of_timeline_in_folder(root_folder, timeline)
    print(f"found in {timeline} - markin {markIn} - markout {markOut}")
    return markIn, markOut


def get_marker_count_by_color(markers):
    marker_count_by_color = {"Any": 0}
    for _, marker in markers.items():
        if marker["color"] not in marker_count_by_color:
            marker_count_by_color[marker["color"]] = 0
        marker_count_by_color[marker["color"]] += 1
        marker_count_by_color["Any"] += 1
    return marker_count_by_color


def get_timeline_project_resolution(project, timeline):
    return (
        int(timeline.GetSetting("timelineResolutionWidth")),
        int(timeline.GetSetting("timelineResolutionHeight")),
        int(project.GetSetting("timelineResolutionWidth")),
        int(project.GetSetting("timelineResolutionHeight")),
    )


def timeline_resolution_override(project, timeline, resolution_tuple, resolution_percentage):
    res_t_width, res_t_height, res_p_width, res_p_height = resolution_tuple
    res_timeline_width = res_t_width * (int(resolution_percentage) / 100)
    res_timeline_height = res_t_height * (int(resolution_percentage) / 100)
    res_project_width = res_p_width * (int(resolution_percentage) / 100)
    res_project_height = res_p_height * (int(resolution_percentage) / 100)
    return (
        timeline.SetSetting("timelineResolutionWidth", str(int(res_timeline_width))),
        timeline.SetSetting("timelineResolutionHeight", str(int(res_timeline_height))),
        project.SetSetting("timelineResolutionWidth", str(int(res_project_width))),
        project.SetSetting("timelineResolutionHeight", str(int(res_project_height))),
    )


stills = {
    "formats": {
        "dpx": "DPX Files (*.dpx)",
        "cin": "Cineon Files (*.cin)",
        "tif": "TIFF Files (*.tif)",
        "jpg": "JPEG Files (*.jpg)",
        "png": "PNG Files (*.png)",
        "ppm": "PPM Files (*.ppm)",
        "bmp": "BMP Files (*.bmp)",
        "xpm": "XPM Files (*.xpm)",
        "sort_order": ["dpx", "cin", "tif", "jpg", "png", "ppm", "bmp", "xpm"],
    },
    "reselect_album": reselect_album,
}

markers_dict = {
    "get_marker_count_by_color": get_marker_count_by_color,
    "colors": [
        "Blue",
        "Cyan",
        "Green",
        "Yellow",
        "Red",
        "Pink",
        "Purple",
        "Fuchsia",
        "Rose",
        "Lavender",
        "Sky",
        "Mint",
        "Lemon",
        "Sand",
        "Cocoa",
        "Cream",
    ],
}

dict_settings = {
    "markers": "Any",
    "export": True,
    "export_to": "",
    "format": "jpg",
    "resize_stills": False,
    "resize_percentage": 50,
    "replace_original_exports": True,
    "rename_with_meta": False,
    "restrict_to_in_out": True,
    "remove_drx": True,
    "create_export_folder_timeline_name": True,
    "create_sub_folder": True,
    "sub_folder_name": "Stills",
    "compress": False,
    "export_edl_markers": False,
    "rename_format_style": "US",
    "rename_fallback_shot_from_scene": True,
    "rename_scene_shot_separator": "/",
    "burnin": False,
    "burnin_font_path": "",
    "burnin_font_ratio": 0.015,
    "burnin_min_font_size": 18,
    "burnin_max_font_size": 96,
    "burnin_opacity": 0.5,
    "burnin_margin": 18,
    "burnin_auto_font": True
}


def export_markers_to_edl(timeline, markers_dict, edl_path):
    def frames_to_tc(frame, fps):
        fps = float(fps)
        f = int(round(frame))
        hh = int(f // int(fps * 3600))
        f -= int(hh * fps * 3600)
        mm = int(f // int(fps * 60))
        f -= int(mm * fps * 60)
        ss = int(f // int(fps))
        ff = int(f - int(ss * fps))
        return f"{hh:02d}:{mm:02d}:{ss:02d}:{ff:02d}"

    fps = float(timeline.GetSetting("timelineFrameRate") or 24.0)
    frames = sorted(markers_dict.keys(), key=lambda x: float(x))

    title = timeline.GetName() or "Timeline"
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    lines = []
    lines.append(f"TITLE: {title}")
    lines.append("FCM: NON-DROP FRAME")
    lines.append(f"* MARKERS EDL EXPORT {now}")
    lines.append("")

    idx = 1
    for fr in frames:
        m = markers_dict[fr] or {}
        color = (m.get("color") or "").strip()
        name = (m.get("name") or "").strip()
        note = (m.get("note") or "").strip()
        dur = m.get("duration") or 1
        try:
            dur = float(dur)
        except:
            dur = 1.0

        timeline_start = timeline.GetStartFrame()

        start_tc = timecode_from_frame(
            timeline_start + int(float(fr)),
            fps,
            False
        )

        end_tc = timecode_from_frame(
            timeline_start + int(float(fr) + dur),
            fps,
            False
        )

        lines.append(f"{idx:03d}  AX       V     C        00:00:00:00 00:00:00:01 {start_tc} {end_tc}")
        if color:
            lines.append(f"* COLOR: {color}")
        if name:
            lines.append(f"* NAME: {name}")
        if note:
            note_one_line = " ".join(note.splitlines()).strip()
            lines.append(f"* NOTE: {note_one_line}")
        lines.append("")
        idx += 1

    os.makedirs(os.path.dirname(edl_path), exist_ok=True)
    with open(edl_path, "w", encoding="utf-8", newline="\n") as f:
        f.write("\n".join(lines))


def _choose_macos_font(font_path, font_size):
    candidates = []
    if font_path and os.path.exists(font_path):
        candidates.append(font_path)

    candidates += [
        "/System/Library/Fonts/Helvetica.ttc",
        "/System/Library/Fonts/Supplemental/Arial.ttf",
        "/System/Library/Fonts/Supplemental/Helvetica.ttf",
        "/Library/Fonts/Arial.ttf",
        "/Library/Fonts/Helvetica.ttf",
    ]

    for p in candidates:
        if p and os.path.exists(p):
            try:
                return ImageFont.truetype(p, int(font_size))
            except:
                pass

    return ImageFont.load_default()


def burnin_3zones_top_white(
    image_path,
    timeline_name,
    center_text,
    right_text,
    out_path=None,
    font_path=None,
    font_size=None,              # ignoré si auto
    margin=18,
    opacity=1.0,
    auto_font=True,              # nouveau
    font_ratio=0.015,            # nouveau: 2.2% de la largeur
    min_font_size=18,            # nouveau
    max_font_size=96,            # nouveau
):
    base = Image.open(image_path).convert("RGBA")
    W, H = base.size

    if auto_font:
        fs = int(round(W * float(font_ratio)))
        fs = max(int(min_font_size), min(int(max_font_size), fs))
    else:
        fs = int(font_size or 24)

    font = _choose_macos_font(font_path, fs)

    opacity = float(opacity) if opacity is not None else 1.0
    opacity = max(0.0, min(1.0, opacity))
    alpha = int(255 * opacity)
    fill = (255, 255, 255, alpha)

    overlay = Image.new("RGBA", (W, H), (0, 0, 0, 0))
    draw = ImageDraw.Draw(overlay)

    def tsize(t):
        if not t:
            return (0, 0)
        bbox = draw.textbbox((0, 0), t, font=font)
        return (bbox[2] - bbox[0], bbox[3] - bbox[1])

    y = margin

    left = timeline_name or ""
    draw.text((margin, y), left, font=font, fill=fill)

    cw, _ = tsize(center_text or "")
    cx = int((W - cw) / 2)
    draw.text((cx, y), center_text or "", font=font, fill=fill)

    rw, _ = tsize(right_text or "")
    rx = max(margin, W - margin - rw)
    draw.text((rx, y), right_text or "", font=font, fill=fill)

    out = Image.alpha_composite(base, overlay)

    if out_path is None:
        out_path = image_path

    ext = os.path.splitext(out_path)[1].lower()
    if ext in [".jpg", ".jpeg"]:
        out.convert("RGB").save(out_path, quality=95)
    else:
        out.save(out_path)

    return out_path


settings = load_settings_from_json(dict_settings)
# --- Override burnin settings from web config if available ---
burnin_web_settings = load_burnin_web_settings()
if burnin_web_settings:
    for k, v in burnin_web_settings.items():
        if k.startswith("burnin_"):
            settings[k] = v

ui = fusion.UIManager
dispatcher = bmd.UIDispatcher(ui)


def _list_images_mtimes(folder, ext):
    if not folder or not os.path.isdir(folder):
        return {}
    ext = "." + ext.lower().lstrip(".")
    out = {}
    for fn in os.listdir(folder):
        if fn.lower().endswith(ext):
            p = os.path.join(folder, fn)
            if os.path.isfile(p):
                try:
                    out[p] = os.path.getmtime(p)
                except:
                    pass
    return out


def export_stills_and_get_new_files(still_album, stills_list, output_path, prefix, fmt):
    """
    Retourne les fichiers créés OU réécrits (mtime augmenté).
    Gère correctement les overwrites.
    """
    before = _list_images_mtimes(output_path, fmt)

    ok = still_album.ExportStills(stills_list, output_path, prefix, fmt)
    if not ok:
        return False, []

    after = _list_images_mtimes(output_path, fmt)

    changed = []
    for p, m_after in after.items():
        m_before = before.get(p)
        if (m_before is None) or (m_after > m_before + 1e-6):
            changed.append(p)

    changed.sort(key=lambda p: after.get(p, 0.0))
    return True, changed


def parse_resolution_str(res_str):
    """
    Convertit "1920x1080" en (1920,1080). Retourne (None,None) si inconnu.
    """
    if not res_str:
        return None, None
    s = str(res_str).lower().replace(" ", "")
    if "x" not in s:
        return None, None
    a, b = s.split("x", 1)
    try:
        return int(a), int(b)
    except:
        return None, None


def get_source_resolution_and_tc_at_playhead(timeline, timeline_abs_frame, frame_rate, drop_frame):
    """
    Retourne (src_res_text, src_tc_text)
    - src_res_text : "1920x1080" si dispo
    - src_tc_text  : timecode SOURCE au playhead (pas timeline)
    """
    item = timeline.GetCurrentVideoItem()
    if not item:
        return "", ""

    mpi = item.GetMediaPoolItem()
    props = mpi.GetClipProperty() if mpi else {}

    # Résolution source
    src_res = (props.get("Resolution") or props.get("Format") or "").strip()
    # Certains Resolve renvoient parfois "1920 x 1080"
    if src_res:
        w, h = parse_resolution_str(src_res.replace(" x ", "x").replace("X", "x"))
        if w and h:
            src_res = f"{w}x{h}"

    # Timecode source
    start_tc = (props.get("Start TC") or props.get("Start Timecode") or "").strip()
    if not start_tc:
        return src_res, ""

    # On calcule l’offset dans le clip au frame timeline courant
    # Méthodes Resolve usuelles: GetStart(), GetLeftOffset()
    try:
        item_start = item.GetStart()  # frame timeline où commence l’item
    except:
        item_start = None

    try:
        left_off = item.GetLeftOffset()  # frames "trim" côté gauche
    except:
        left_off = 0

    if item_start is None:
        # Impossible de calculer proprement l’offset
        return src_res, ""

    # frame dans le clip (en frames source)
    clip_frame_offset = int(timeline_abs_frame - int(item_start) + int(left_off))
    if clip_frame_offset < 0:
        clip_frame_offset = 0

    # Start TC source -> frames source
    try:
        start_frames = frame_from_timecode(start_tc, frame_rate, drop_frame)
    except:
        return src_res, ""

    src_frames_at_playhead = int(start_frames + clip_frame_offset)
    src_tc = timecode_from_frame(src_frames_at_playhead, frame_rate, drop_frame)

    return src_res, src_tc



def _first(d, keys):
    for k in keys:
        v = d.get(k)
        if v is not None and str(v).strip() != "":
            return str(v).strip()
    return ""

# Case-insensitive version of _first
def _first_ci(d, keys):
    """
    Case-insensitive version of _first.
    Returns first non-empty value for any key in keys,
    matching dictionary keys case-insensitively.
    """
    if not isinstance(d, dict):
        return ""
    lower_map = {str(k).lower(): v for k, v in d.items()}
    for k in keys:
        v = lower_map.get(str(k).lower())
        if v is not None and str(v).strip() != "":
            return str(v).strip()
    return ""


def extract_fields_at_playhead(timeline):
    item = timeline.GetCurrentVideoItem()
    clipname = item.GetName() if item else ""
    mpi = item.GetMediaPoolItem() if item else None

    meta = mpi.GetMetadata() if mpi else {}
    props = mpi.GetClipProperty() if mpi else {}

    scene = _first(meta, ["Scene", "Scene Number"]) or _first(props, ["Scene"])
    shot = _first(meta, ["Shot", "Shot Number"]) or _first(props, ["Shot"])
    take = _first(meta, ["Take", "Take Number"]) or _first(props, ["Take"])

    camera = _first(meta, ["Camera #", "Camera", "Camera Number"]) or _first(props, ["Camera #", "Camera"])
    good_take = _first(meta, ["Good Take", "GoodTake"]) or _first(props, ["Good Take", "GoodTake"])

    return clipname, scene, shot, take, camera, good_take

# ---------------------------------------------------------------------------
# NEW: Collect all available metadata and clip properties at playhead
def collect_full_metadata_at_playhead(timeline, timeline_abs_frame, frame_rate, drop_frame):
    """
    Collect ALL available metadata and clip properties for current playhead position.
    Returns a fully serializable dict.
    """
    item = timeline.GetCurrentVideoItem()
    if not item:
        return {}

    mpi = item.GetMediaPoolItem()
    meta = mpi.GetMetadata() if mpi else {}
    props = mpi.GetClipProperty() if mpi else {}

    src_res_txt, src_tc_txt = get_source_resolution_and_tc_at_playhead(
        timeline=timeline,
        timeline_abs_frame=timeline_abs_frame,
        frame_rate=frame_rate,
        drop_frame=drop_frame,
    )

    data = {
        "timeline_frame": int(timeline_abs_frame),
        "timeline_tc": timeline.GetCurrentTimecode(),
        "clip_name": item.GetName(),
        "source_tc": src_tc_txt,
        "source_resolution": src_res_txt,
        "clip_start_frame": item.GetStart() if hasattr(item, "GetStart") else None,
        "clip_left_offset": item.GetLeftOffset() if hasattr(item, "GetLeftOffset") else None,
        "metadata": meta,
        "clip_properties": props,
    }

    return data


def create_window(marker_count_by_color, markers, still_album_name, timeline_settings):
    winID = "com.blackmagicdesign.resolve.stills_marker"
    win_name = "Stills Marker"

    marker_combo_boxID = "MarkersComboBox"
    info_labelID = "InfoLabel"

    export_check_boxID = "ExportCheckBox"
    export_settingsID = "ExportSettings"
    export_to_line_editID = "ExportToLineEdit"
    browse_buttonID = "BrowseButton"
    export_edl_markers_check_boxID = "ExportEdlMarkersCheckBox"

    restrict_to_in_out_check_boxID = "RestrictToInOutCheckBox"

    rename_with_meta_check_boxID = "RenameWithMetaCheckBox"
    rename_format_combo_boxID = "RenameFormatComboBox"
    rename_options_groupID = "RenameOptionsGroup"
    rename_fallback_check_boxID = "RenameFallbackShotCheckBox"
    rename_sep_line_editID = "RenameSceneShotSeparatorLineEdit"

    format_combo_boxID = "FormatComboBox"

    remove_drx_check_boxID = "RemoveDrxCheckBox"

    create_timeline_folder_check_boxID = "CreateTimelineFolderCheckBox"
    create_sub_folder_check_boxID = "CreateSubFolderCheckBox"
    sub_folder_name_line_editID = "SubFolderNameLineEdit"

    resize_check_boxID = "ResizeCheckBox"
    resize_line_editID = "ResizeLineEdit"
    resize_replace_check_boxID = "ResizeReplaceCheckBox"

    burnin_setting_boxID = "BurninSettings"
    burnin_check_boxID = "BurninCheckBox"

    compress_setting_boxID = "CompressSettings"
    compress_check_boxID = "CompressCheckBox"

    cancel_buttonID = "CancelButton"
    start_buttonID = "StartButton"

    main_window = ui.FindWindow(winID)
    if main_window:
        main_window.Show()
        main_window.Raise()
        exit()

    left_column_minimum_size = {100, 0}
    left_column_maximum_size = {100, 16777215}

    window_flags = {"Dialog": True}

    def hline(height=1, color="#444"):
        return ui.Label(
            {
                "Weight": 0,
                "Text": "",
                "MinimumSize": [0, height],
                "MaximumSize": [16777215, height],
                "StyleSheet": f"background-color: {color};",
            }
        )

    main_window = dispatcher.AddWindow(
        {
            "ID": winID,
            "WindowTitle": win_name,
            "WindowFlags": window_flags,
            "WindowModality": "ApplicationModal",
            "FixedSize": [580, 360],
            "Events": {"Close": True, "KeyPress": True},
        },
        ui.VGroup(
            {"MinimumSize": [580, 360], "MaximumSize": [580, 360], "Weight": 1},
            [
                ui.HGroup(
                    {"Weight": 0, "Spacing": 10},
                    [
                        ui.Label(
                            {
                                "Weight": 0,
                                "Alignment": {"AlignRight": True, "AlignVCenter": True},
                                "MinimumSize": left_column_minimum_size,
                                "MaximumSize": left_column_maximum_size,
                                "Text": "Timeline markers",
                            }
                        ),
                        ui.ComboBox({"Weight": 1, "ID": marker_combo_boxID}),
                        ui.Label(
                            {
                                "Weight": 0,
                                "Alignment": {"AlignRight": True, "AlignVCenter": True},
                                "MinimumSize": [95, 0],
                                "MaximumSize": [95, 16777215],
                                "Text": "Restrict to In/Out",
                            }
                        ),
                        ui.CheckBox(
                            {
                                "Weight": 0,
                                "ID": restrict_to_in_out_check_boxID,
                                "Checked": settings["restrict_to_in_out"],
                                "Events": {"Toggled": True},
                                "MinimumSize": [90, 0],
                                "MaximumSize": [90, 16777215],
                            }
                        ),
                    ],
                ),
                ui.HGroup(
                    {"Weight": 0, "Spacing": 10},
                    [
                        ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                        ui.Label({"Weight": 1, "ID": info_labelID}),
                    ],
                ),
                ui.VGap(6),
                hline(1),
                ui.HGroup(
                    {"Weight": 0, "Spacing": 10},
                    [
                        ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                        ui.CheckBox(
                            {
                                "Weight": 1,
                                "ID": rename_with_meta_check_boxID,
                                "Text": "Rename with metadata",
                                "Checked": settings["rename_with_meta"],
                                "Events": {"Toggled": True},
                            }
                        ),
                        ui.Label(
                            {"Weight": 0, "Alignment": {"AlignRight": True, "AlignVCenter": True}, "MinimumSize": [60, 0], "MaximumSize": [60, 16777215], "Text": "Style"}
                        ),
                        ui.ComboBox({"Weight": 1, "ID": rename_format_combo_boxID, "MinimumSize": [60, 0], "MaximumSize": [60, 16777215]}),
                    ],
                ),
                ui.VGroup(
                    {"ID": rename_options_groupID, "Weight": 0, "Enabled": settings.get("rename_with_meta", False)},
                    [
                        ui.HGroup(
                            {"Weight": 0, "Spacing": 10},
                            [
                                ui.Label(
                                    {
                                        "Weight": 0,
                                        "Alignment": {"AlignRight": True, "AlignVCenter": True},
                                        "MinimumSize": left_column_minimum_size,
                                        "MaximumSize": left_column_maximum_size,
                                        "Text": "Fallback Shot",
                                    }
                                ),
                                ui.CheckBox(
                                    {
                                        "Weight": 1,
                                        "ID": rename_fallback_check_boxID,
                                        "Text": "parse Shot from Scene",
                                        "Checked": settings.get("rename_fallback_shot_from_scene", True),
                                        "Events": {"Toggled": True},
                                    }
                                ),
                                ui.Label(
                                    {
                                        "Weight": 0,
                                        "Alignment": {"AlignRight": True, "AlignVCenter": True},
                                        "MinimumSize": [95, 0],
                                        "MaximumSize": [95, 16777215],
                                        "Text": "Scene separator",
                                    }
                                ),
                                ui.LineEdit(
                                    {
                                        "Weight": 1,
                                        "ID": rename_sep_line_editID,
                                        "Text": settings.get("rename_scene_shot_separator", "/"),
                                        "Alignment": {"AlignHCenter": True},
                                        "MinimumSize": [60, 0],
                                        "MaximumSize": [60, 16777215],
                                    }
                                ),
                            ],
                        )
                    ],
                ),
                ui.VGap(6),
                hline(1),
                ui.HGroup(
                    {"Weight": 0, "Spacing": 10},
                    [
                        ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                        ui.CheckBox({"Weight": 1, "ID": export_check_boxID, "Text": "Export grabbed stills", "Checked": settings["export"], "Events": {"Toggled": True}}),

                        ui.Label({"Weight": 0, "Alignment": {"AlignRight": True, "AlignVCenter": True}, "MinimumSize": [60, 0], "MaximumSize": [60, 16777215], "Text": "Format"}),
                        ui.ComboBox({"Weight": 1, "ID": format_combo_boxID, "MinimumSize": [120, 0], "MaximumSize": [140, 16777215]}),
                        ui.HGroup(
                            {"Weight": 0, "Spacing": 10},
                            [
                                ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                                ui.CheckBox({"Weight": 0, "ID": export_edl_markers_check_boxID, "Text": "Export EDL markers", "Checked": settings.get("export_edl_markers", False), "Events": {"Toggled": True}}),
                                ui.HGap(0, 1),
                            ],
                        ),
                    ],
                ),
                ui.VGap(2),
                ui.VGroup(
                    {"ID": export_settingsID, "Weight": 0, "Enabled": settings["export"]},
                    [
                        ui.HGroup(
                            {"Weight": 0, "Spacing": 10},
                            [
                                ui.Label({"Weight": 0, "Alignment": {"AlignRight": True, "AlignVCenter": True}, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size, "Text": "Export to"}),
                                ui.LineEdit({"Weight": 1, "ID": export_to_line_editID, "Text": settings["export_to"]}),
                                ui.Button({"Weight": 0, "ID": browse_buttonID, "Text": "Browse", "AutoDefault": False}),
                            ],
                        ),
                        ui.HGroup(
                            {"Weight": 0, "Spacing": 10},
                            [
                                ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                                ui.CheckBox({"Weight": 0, "ID": create_timeline_folder_check_boxID, "Text": "Create Folder with timeline name", "Checked": settings["create_export_folder_timeline_name"], "Events": {"Toggled": True}}),
                                ui.CheckBox({"Weight": 0, "ID": create_sub_folder_check_boxID, "Text": "Create sub folder:", "Checked": settings["create_sub_folder"], "Events": {"Toggled": True}}),
                                ui.LineEdit({"Weight": 1, "ID": sub_folder_name_line_editID, "Text": settings["sub_folder_name"], "MinimumSize": [100, 0], "MaximumSize": [100, 16777215]}),
                            ],
                        ),
                        ui.HGroup(
                            {"Weight": 0, "Spacing": 10},
                            [
                                ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                                ui.CheckBox({"Weight": 0, "ID": resize_check_boxID, "Text": "Resize stills in %", "Checked": settings["resize_stills"], "Events": {"Toggled": True}}),
                                ui.Label({"Weight": 0, "Alignment": {"AlignRight": True, "AlignVCenter": True}, "MinimumSize": [60, 0], "MaximumSize": [60, 16777215], "Text": "Resize to"}),
                                ui.LineEdit({"Weight": 1, "ID": resize_line_editID, "Text": str(settings["resize_percentage"]), "MinimumSize": [40, 0], "MaximumSize": [40, 16777215], "Alignment": {"AlignHCenter": True}}),
                                ui.Label({"Weight": 0, "Text": "%"}),
                                ui.CheckBox({"Weight": 0, "ID": resize_replace_check_boxID, "Text": "Replace originals", "Checked": settings["replace_original_exports"], "Events": {"Toggled": True}}),
                                ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                                ui.CheckBox({"Weight": 0, "ID": remove_drx_check_boxID, "Text": "Remove DRX files", "Checked": settings["remove_drx"], "Events": {"Toggled": True}}),
                            ],
                        ),
                        # ui.HGroup(
                        #     {"ID": burnin_setting_boxID, "Weight": 0, "Spacing": 10},
                        #     [
                        #         ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                        #         ui.CheckBox({"Weight": 0, "ID": burnin_check_boxID, "Text": "Burnins", "Checked": settings.get("burnin", False), "Events": {"Toggled": True}}),
                        #     ],
                        # ),
                        # ui.HGroup(
                        #     {"ID": compress_setting_boxID, "Weight": 0, "Spacing": 10, "Enabled": settings["format"] == "jpg"},
                        #     [
                        #         ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                        #         ui.CheckBox({"Weight": 0, "ID": compress_check_boxID, "Text": "Compress JPEG with ImageOptim", "Checked": settings["compress"], "Events": {"Toggled": True}}),
                        #     ],
                        # ),
                        ui.HGroup(
                            {"ID": compress_setting_boxID, "Weight": 0, "Spacing": 10},
                            [
                                ui.Label({"Weight": 0, "MinimumSize": left_column_minimum_size, "MaximumSize": left_column_maximum_size}),
                                ui.CheckBox(
                                    {
                                        "Weight": 0,
                                        "ID": burnin_check_boxID,
                                        "Text": "Burnins",
                                        "Checked": settings.get("burnin", False),
                                        "Events": {"Toggled": True},
                                    }
                                ),
                                ui.HGap(12),
                                ui.CheckBox(
                                    {
                                        "Weight": 0,
                                        "ID": compress_check_boxID,
                                        "Text": "Compress JPEG with ImageOptim",
                                        "Checked": settings.get("compress", False),
                                        "Events": {"Toggled": True},
                                    }
                                ),
                                ui.HGap(0, 1),
                            ],
                        )
                    ],
                ),
                ui.VGap(6),
                ui.HGroup(
                    {
                        "Weight": 0,
                        "Spacing": 10,
                        "StyleSheet": """
                            QPushButton
                            {
                                min-height: 22px;
                                max-height: 22px;
                                min-width: 108px;
                                max-width: 108px;
                            }
                        """,
                    },
                    [
                        ui.HGap(0, 1),
                        ui.Button({"Weight": 0, "ID": cancel_buttonID, "Text": "Cancel", "AutoDefault": False}),
                        ui.Button({"Weight": 0, "ID": start_buttonID, "Text": "Start", "AutoDefault": False}),
                    ],
                ),
            ],
        ),
    )

    window_items = main_window.GetItems()

    def update_controls():
        marker_src = markers if not settings["restrict_to_in_out"] else markers_in_out
        marker_count_by_color_local = markers_dict["get_marker_count_by_color"](marker_src)

        export_on = window_items[export_check_boxID].Checked
        edl_on = window_items[export_edl_markers_check_boxID].Checked if export_edl_markers_check_boxID in window_items else settings.get("export_edl_markers", False)

        need_output_dir = export_on or edl_on
        start_button_enabled = (not need_output_dir) or (len(window_items[export_to_line_editID].Text.strip()) > 0)

        # Export SETTINGS (resize, burnin, compress…) → uniquement export fichiers
        window_items[export_settingsID].Enabled = export_on

        window_items[export_to_line_editID].Enabled = need_output_dir
        window_items[browse_buttonID].Enabled = need_output_dir

        window_items[format_combo_boxID].Enabled = export_on

        # Folder options are enabled if either disk export OR EDL export is enabled
        folder_opts_on = export_on or edl_on

        window_items[create_timeline_folder_check_boxID].Enabled = folder_opts_on
        window_items[create_sub_folder_check_boxID].Enabled = folder_opts_on
        window_items[sub_folder_name_line_editID].Enabled = window_items[create_sub_folder_check_boxID].Checked

        resize_on = window_items[resize_check_boxID].Checked
        window_items[resize_check_boxID].Enabled = export_on
        window_items[resize_line_editID].Enabled = export_on and resize_on
        window_items[resize_replace_check_boxID].Enabled = export_on

        window_items[remove_drx_check_boxID].Enabled = export_on

        # Burnins: indépendant de Compress, mais logique = uniquement utile si export fichier
        window_items[burnin_check_boxID].Enabled = export_on

        # Compress: uniquement si export fichier + jpg + ImageOptim installé
        compress_enabled = export_on and (settings["format"] == "jpg") and detect_system_and_image_optim_installed()
        window_items[compress_check_boxID].Enabled = compress_enabled

        rename_on = window_items[rename_with_meta_check_boxID].Checked
        window_items[rename_options_groupID].Enabled = rename_on
        window_items[rename_format_combo_boxID].Enabled = rename_on

        window_items[rename_sep_line_editID].Enabled = rename_on and window_items[rename_fallback_check_boxID].Checked

        marker_count = marker_count_by_color_local.get(window_items[marker_combo_boxID].CurrentText)
        if marker_count is not None and marker_count > 0:
            marker_plural = "" if marker_count == 1 else "s"
            window_items[info_labelID].Text = f'{marker_count} still{marker_plural} will be grabbed to the "{still_album_name}" album'
        else:
            marker_color = "" if window_items[marker_combo_boxID].CurrentText == "Any" else window_items[marker_combo_boxID].CurrentText.lower() + " "
            window_items[info_labelID].Text = f"No {marker_color}markers found, no stills will be grabbed"
            start_button_enabled = False

        window_items[start_buttonID].Enabled = start_button_enabled
        window_items[export_to_line_editID].ToolTip = window_items[export_to_line_editID].Text

    def initialize_controls():
        window_items[marker_combo_boxID].AddItem("Any")
        window_items[marker_combo_boxID].AddItems(markers_dict["colors"])
        window_items[marker_combo_boxID].InsertSeparator(1)
        window_items[marker_combo_boxID].CurrentText = settings["markers"]

        for fmt in stills["formats"]["sort_order"]:
            window_items[format_combo_boxID].AddItem(stills["formats"][fmt])
        window_items[format_combo_boxID].CurrentText = stills["formats"][settings["format"]]

        window_items[rename_format_combo_boxID].AddItem("US")
        window_items[rename_format_combo_boxID].AddItem("EU")
        window_items[rename_format_combo_boxID].CurrentText = settings.get("rename_format_style", "EU")

        update_controls()

    initialize_controls()

    def OnGenericToggled(ev):
        update_controls()

    def OnMarkersComboBoxCurrentIndexChanged(ev):
        update_controls()

    def OnRestrictToInOutCheckBoxToggled(ev):
        settings["restrict_to_in_out"] = window_items[restrict_to_in_out_check_boxID].Checked
        update_controls()

    def OnFormatComboBoxCurrentIndexChanged(ev):
        settings["format"] = stills["formats"]["sort_order"][window_items[format_combo_boxID].CurrentIndex]
        update_controls()

    def OnBrowseButtonClicked(ev):
        selectedDir = fusion.RequestDir(window_items[export_to_line_editID].Text, {"FReqS_Title": "Export to"})
        if selectedDir:
            window_items[export_to_line_editID].Text = selectedDir
        update_controls()

    def OnRenameFormatComboBoxCurrentIndexChanged(ev):
        settings["rename_format_style"] = window_items[rename_format_combo_boxID].CurrentText
        update_controls()

    def OnCancelButtonClicked(ev):
        dispatcher.ExitLoop(False)

    def OnStartButtonClicked(ev):
        settings["markers"] = window_items[marker_combo_boxID].CurrentText
        settings["export"] = window_items[export_check_boxID].Checked
        settings["export_to"] = window_items[export_to_line_editID].Text
        settings["format"] = stills["formats"]["sort_order"][window_items[format_combo_boxID].CurrentIndex]
        settings["export_edl_markers"] = window_items[export_edl_markers_check_boxID].Checked

        settings["restrict_to_in_out"] = window_items[restrict_to_in_out_check_boxID].Checked

        settings["rename_with_meta"] = window_items[rename_with_meta_check_boxID].Checked
        settings["rename_format_style"] = window_items[rename_format_combo_boxID].CurrentText
        settings["rename_fallback_shot_from_scene"] = window_items[rename_fallback_check_boxID].Checked
        settings["rename_scene_shot_separator"] = window_items[rename_sep_line_editID].Text

        settings["remove_drx"] = window_items[remove_drx_check_boxID].Checked
        settings["create_export_folder_timeline_name"] = window_items[create_timeline_folder_check_boxID].Checked
        settings["create_sub_folder"] = window_items[create_sub_folder_check_boxID].Checked
        settings["sub_folder_name"] = window_items[sub_folder_name_line_editID].Text

        settings["resize_stills"] = window_items[resize_check_boxID].Checked
        settings["resize_percentage"] = window_items[resize_line_editID].Text
        settings["replace_original_exports"] = window_items[resize_replace_check_boxID].Checked

        settings["compress"] = window_items[compress_check_boxID].Checked
        settings["burnin"] = window_items[burnin_check_boxID].Checked

        save_settings_to_json(settings)
        dispatcher.ExitLoop(True)

    def OnWindowKeyPress(ev):
        if ev["Key"] == 16777216:  # Escape
            dispatcher.ExitLoop(False)
            return

        if ev["Key"] == 16777220:  # Enter
            OnStartButtonClicked(ev)

    def OnClose(ev):
        dispatcher.ExitLoop()

    main_window.On[marker_combo_boxID].CurrentIndexChanged = OnMarkersComboBoxCurrentIndexChanged
    main_window.On[export_check_boxID].Toggled = OnGenericToggled
    main_window.On[restrict_to_in_out_check_boxID].Toggled = OnRestrictToInOutCheckBoxToggled

    main_window.On[rename_with_meta_check_boxID].Toggled = OnGenericToggled
    main_window.On[rename_fallback_check_boxID].Toggled = OnGenericToggled
    main_window.On[rename_format_combo_boxID].CurrentIndexChanged = OnRenameFormatComboBoxCurrentIndexChanged

    main_window.On[browse_buttonID].Clicked = OnBrowseButtonClicked
    main_window.On[export_to_line_editID].TextChanged = OnGenericToggled

    main_window.On[remove_drx_check_boxID].Toggled = OnGenericToggled
    main_window.On[create_timeline_folder_check_boxID].Toggled = OnGenericToggled
    main_window.On[create_sub_folder_check_boxID].Toggled = OnGenericToggled
    main_window.On[sub_folder_name_line_editID].TextChanged = OnGenericToggled

    main_window.On[resize_check_boxID].Toggled = OnGenericToggled
    main_window.On[resize_line_editID].TextChanged = OnGenericToggled
    main_window.On[resize_replace_check_boxID].Toggled = OnGenericToggled

    main_window.On[format_combo_boxID].CurrentIndexChanged = OnFormatComboBoxCurrentIndexChanged
    main_window.On[compress_check_boxID].Toggled = OnGenericToggled
    main_window.On[burnin_check_boxID].Toggled = OnGenericToggled

    main_window.On[cancel_buttonID].Clicked = OnCancelButtonClicked
    main_window.On[start_buttonID].Clicked = OnStartButtonClicked
    main_window.On[winID].KeyPress = OnWindowKeyPress
    main_window.On[winID].Close = OnClose

    return main_window


project = resolve.GetProjectManager().GetCurrentProject()
assert project, "Couldn't get current project"
gallery = project.GetGallery()
assert gallery, "Couldn't get the Resolve stills gallery"
still_album = gallery.GetCurrentStillAlbum()
assert still_album, "Couldn't get the current gallery still album"
still_album_name = gallery.GetAlbumName(still_album)
timeline = project.GetCurrentTimeline()
assert timeline, "Couldn't get current timeline"

timeline_start = timeline.GetStartFrame()
frame_rate = timeline.GetSetting("timelineFrameRate")
drop_frame = int(timeline.GetSetting("timelineDropFrameTimecode"))

markIn, markOut = detect_in_out_point_timeline(project, timeline)
markIn_frame = frame_from_timecode(markIn, frame_rate, drop_frame)
markOut_frame = frame_from_timecode(markOut, frame_rate, drop_frame)
resolution_tuple = get_timeline_project_resolution(project, timeline)

timeline_settings = {
    "timeline_start": timeline_start,
    "frame_rate": frame_rate,
    "drop_frame": drop_frame,
    "markIn": markIn,
    "markOut": markOut,
    "markIn_frame": markIn_frame,
    "markOut_frame": markOut_frame,
}

markers = timeline.GetMarkers()

if markers:
    marker_frames_all = sorted(markers.keys())

    markers_in_out = markers.copy()
    marker_to_delete = []
    for marker_frame in marker_frames_all:
        marker_offset_frame = timeline_start + marker_frame
        if marker_offset_frame < markIn_frame or marker_offset_frame > markOut_frame:
            marker_to_delete.append(marker_frame)

    print(f"delete {len(marker_to_delete)} marker outside of in out points")
    for marker_frame in marker_to_delete:
        del markers_in_out[marker_frame]

    marker_count_by_color = markers_dict["get_marker_count_by_color"](markers if not settings["restrict_to_in_out"] else markers_in_out)
    window = create_window(marker_count_by_color, markers, still_album_name, timeline_settings)
    window.Show()
    grab_stills = dispatcher.RunLoop()
    window.Hide()
    print("launching script main loop and grab_stills is ", grab_stills)

    if grab_stills:
        initial_state = change_page("color")

        # Build markers source after UI (because settings may have changed)
        markers_src = markers if not settings.get("restrict_to_in_out", False) else markers_in_out
        marker_frames = sorted(markers_src.keys())

        # Timeline resolution override (only makes sense for disk export)
        if settings.get("resize_stills", False) \
           and int(settings.get("resize_percentage", 100)) > 100 \
           and settings.get("export", False):

            tres, tres2, pres, pres2 = timeline_resolution_override(
                project,
                timeline,
                resolution_tuple,
                settings["resize_percentage"]
            )
            print(f"timeline resolution override {tres} {tres2} {pres} {pres2}")


        # -------------------------------------------------
        # Disk export path
        # -------------------------------------------------

        if settings.get("export", False):

            output_path = settings["export_to"]

            # Timeline folder
            if settings.get("create_export_folder_timeline_name", False):
                timeline_folder = timeline.GetName().replace(" ", "_")
                output_path = os.path.join(output_path, timeline_folder)

            # Sub folder
            if settings.get("create_sub_folder", False):
                subfolder_name = settings.get("sub_folder_name", "").strip()
                if subfolder_name:
                    output_path = os.path.join(output_path, subfolder_name.replace(" ", "_"))

            os.makedirs(output_path, exist_ok=True)

        # --- EDL path (no folder creation) ---
        elif settings.get("export_edl_markers", False):
            output_path = settings["export_to"]

        # EDL export (filtered by marker color)
        if settings.get("export_edl_markers", False):

            selected_color = settings.get("markers", "Any")

            if selected_color == "Any":
                edl_markers = markers_src
            else:
                edl_markers = {
                    fr: m for fr, m in markers_src.items()
                    if m and m.get("color") == selected_color
                }

            edl_filename = f"{timeline.GetName()}_stillsMarkers.edl".replace(" ", "_")
            edl_path = os.path.join(
                output_path if output_path else settings["export_to"],
                edl_filename
            )

            export_markers_to_edl(timeline, edl_markers, edl_path)

if grab_stills:
    markers_src = markers if not settings.get("restrict_to_in_out", False) else markers_in_out
    marker_frames = sorted(markers_src.keys())

    # --- METADATA COLLECTION DURING GRAB ---
    metadata_json = {
        "timeline": timeline.GetName(),
        "frame_rate": frame_rate,
        "drop_frame": drop_frame,
        "markers_metadata": {}
    }
    metadata_by_frame = metadata_json["markers_metadata"]
    total_markers = len([
        mf for mf in marker_frames
        if markers_src.get(mf)
        and (settings["markers"] == "Any" or settings["markers"] == markers_src.get(mf)["color"])
    ])
    processed_count = 0

    # --- ALWAYS grab stills into gallery ---
    stills_to_export = []

    for marker_frame in marker_frames:
        marker = markers_src.get(marker_frame)
        if not marker:
            continue
        if not (settings["markers"] == "Any" or settings["markers"] == marker["color"]):
            continue

        marker_offset_frame = timeline_start + marker_frame
        tc = timecode_from_frame(marker_offset_frame, frame_rate, drop_frame)

        assert timeline.SetCurrentTimecode(tc), f"Couldn't navigate to marker at {tc}"
        grabbed = timeline.GrabStill()
        if not grabbed:
            raise Exception(f"Couldn't grab still at {tc}")

        stills_to_export.append((grabbed, marker_offset_frame))

        # Collect metadata immediately after grab and write JSON incrementally
        meta_block = collect_full_metadata_at_playhead(
            timeline,
            marker_offset_frame,
            frame_rate,
            drop_frame,
        )

        meta_block["exported_filename"] = None
        metadata_by_frame[str(marker_offset_frame)] = meta_block

        if settings.get("export", False):
            try:
                json_tmp_path = os.path.join(
                    settings.get("export_to", ""),
                    f"{timeline.GetName()}_stills_full_metadata.json".replace(" ", "_")
                )
                with open(json_tmp_path, "w", encoding="utf-8") as jf:
                    json.dump(metadata_json, jf, indent=4)
            except:
                pass

        # processed_count += 1
        # if total_markers > 0:
        #     percent = int((processed_count / total_markers) * 100)
        #     progress_items["ProgressLabel"].Text = f"Processing {processed_count}/{total_markers} ({percent}%)"
        #     dispatcher.ProcessEvents()

        if settings.get("rename_with_meta", False):
            meta_block = metadata_by_frame.get(str(marker_offset_frame), {})

            full_meta = meta_block.get("metadata", {})
            full_props = meta_block.get("clip_properties", {})

            scene = full_meta.get("Scene") or full_meta.get("Scene Number") or full_props.get("Scene") or ""
            shot = full_meta.get("Shot") or full_meta.get("Shot Number") or full_props.get("Shot") or ""
            take = full_meta.get("Take") or full_meta.get("Take Number") or full_props.get("Take") or ""
            camera = full_meta.get("Camera #") or full_meta.get("Camera") or full_meta.get("Camera Number") or full_props.get("Camera") or ""
            clipname = meta_block.get("clip_name", "")

            scene = str(scene).strip()
            shot = str(shot).strip()
            take = str(take).strip()
            camera = str(camera).strip()
            clipname = str(clipname).strip()

            parts = []
            if scene:
                base = scene
                if shot:
                    base += f"_{shot}"
                if take:
                    base += f"_{take}"
                parts.append(base)
            if camera:
                parts.append(camera)
            if clipname:
                parts.append(clipname)

            new_label = "_".join(parts).strip("_")

            if new_label:
                still_album.SetLabel(grabbed, new_label)

# --- DISK EXPORT (optional) ---
if settings.get("export", False) and stills_to_export:
    prefix = ""
    reselect_album(still_album, gallery)

    if settings.get("burnin", False):
        # Export un still à la fois pour burnin fiable
        for grabbed, marker_offset_frame in stills_to_export:

            # repositionner le playhead AVANT de lire les métadonnées
            tc = timecode_from_frame(marker_offset_frame, frame_rate, drop_frame)
            timeline.SetCurrentTimecode(tc)
            ok, new_files = export_stills_and_get_new_files(
                still_album=still_album,
                stills_list=[grabbed],
                output_path=output_path,
                prefix=prefix,
                fmt=settings["format"],
            )
            if not ok or not new_files:
                continue

            for img_path in new_files:
                # --- FULL METADATA FROM PRECOLLECTED DICT ---
                meta_block = metadata_by_frame.get(str(marker_offset_frame), {})

                src_res_txt = meta_block.get("source_resolution", "")
                src_tc_txt = meta_block.get("source_tc", "")
                clipname = meta_block.get("clip_name", "")

                full_meta = meta_block.get("metadata", {})
                full_props = meta_block.get("clip_properties", {})

                scene = full_meta.get("Scene") or full_props.get("Scene") or ""
                shot = full_meta.get("Shot") or full_props.get("Shot") or ""
                take = full_meta.get("Take") or full_props.get("Take") or ""
                camera = full_meta.get("Camera") or full_props.get("Camera") or ""
                good_take = full_meta.get("Good Take") or full_props.get("Good Take") or ""

                star = "*" if str(good_take).strip().lower() in ["1","true","yes"] else ""

                center_parts = []
                if src_res_txt:
                    center_parts.append(f"{src_res_txt} px")
                center_parts.append(clipname)
                if src_tc_txt:
                    center_parts.append(src_tc_txt)

                center_txt = " - ".join(p for p in center_parts if p)
                right_txt = f"{scene}/{shot}-{take} {camera} {star}".strip()

                burnin_3zones_top_white(
                    img_path,
                    timeline_name=timeline.GetName(),
                    center_text=center_txt,
                    right_text=right_txt,
                    out_path=img_path,
                    font_path=settings.get("burnin_font_path") or None,
                    margin=int(settings.get("burnin_margin", 18)),
                    opacity=float(settings.get("burnin_opacity", 0.5)),
                    auto_font=bool(settings.get("burnin_auto_font", True)),
                    font_ratio=float(settings.get("burnin_font_ratio", 0.015)),
                    min_font_size=int(settings.get("burnin_min_font_size", 18)),
                    max_font_size=int(settings.get("burnin_max_font_size", 96)),
                )

                # Register filename in JSON
                meta_block = metadata_by_frame.get(str(marker_offset_frame))
                if meta_block is not None:
                    meta_block["exported_filename"] = os.path.basename(img_path)

    else:
        # Batch export sans burnin
        assert still_album.ExportStills(
            [s for s, _ in stills_to_export],
            output_path,
            prefix,
            settings["format"],
        ), "ExportStills failed"

        # Register exported files in JSON
        exported_files = [
            f for f in os.listdir(output_path)
            if f.lower().endswith("." + settings["format"].lower())
        ]

        for (grabbed, marker_offset_frame), filename in zip(stills_to_export, sorted(exported_files)):
            meta_block = metadata_by_frame.get(str(marker_offset_frame))
            if meta_block is not None:
                meta_block["exported_filename"] = filename

        # Resize stills (applies to both modes, AFTER export)
        if settings.get("resize_stills", False):
            images = [
                os.path.join(output_path, image)
                for image in os.listdir(output_path)
                if image.lower().endswith("." + settings["format"].lower())
            ]
            for image in images:
                resize_image(image, int(settings["resize_percentage"]), settings["replace_original_exports"])

            if int(settings.get("resize_percentage", 100)) > 100:
                timeline_resolution_override(project, timeline, resolution_tuple, 100)
                for image in images:
                    resize_image(image, 100, settings["replace_original_exports"], original_size=resolution_tuple[:2])

        # Compress (jpg only)
        if settings.get("compress", False):
            if detect_system_and_image_optim_installed() and settings.get("format") == "jpg":
                try:
                    imageoptim_command = f'open -a ImageOptim "{output_path}"/*.jpg'
                    subprocess.run(imageoptim_command, shell=True)
                except:
                    print("Couldn't open ImageOptim.app")
                    print("Make sure ImageOptim.app is installed and try again.")
            else:
                print("Couldn't find ImageOptim.app in applications folder (or format not jpg).")

    # --- WRITE FULL METADATA JSON (post-grab, complete data) ---
    try:
        metadata_json_path = os.path.join(
            output_path,
            f"{timeline.GetName()}_stills_full_metadata.json".replace(" ", "_")
        )
        with open(metadata_json_path, "w", encoding="utf-8") as jf:
            json.dump(metadata_json, jf, indent=4)
    except Exception as e:
        print(f"Could not write metadata JSON: {e}")

    # --- FINAL DRX CLEANUP (post-export, reliable) ---
    if settings.get("remove_drx", False) and settings.get("export", False):
        if output_path and os.path.isdir(output_path):
            for root, _, files in os.walk(output_path):
                for fn in files:
                    if fn.lower().endswith(".drx"):
                        try:
                            os.remove(os.path.join(root, fn))
                        except Exception as e:
                            print(f"Could not remove DRX {fn}: {e}")

    restore_page(initial_state)