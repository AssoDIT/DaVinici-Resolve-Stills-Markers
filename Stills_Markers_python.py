#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# MIT License
#
# Copyright (c) 2023 Roger Magnusson
# Translated to python by Bryan Randell
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# -----------------------------------------------------------------------------
#
#
# 	A script that allows you to grab stills from timeline markers and optionally export them to a folder.
#
#   To use the script, copy it to the "Workflow Integration Plugins" folder (or create it) and restart Resolve.
#   Mac OS X:
#     "/Library/Application Support/Blackmagic Design/DaVinci Resolve/Workflow Integration Plugins/"
#   Windows:
#     "%PROGRAMDATA%\Blackmagic Design\DaVinci Resolve\Support\Workflow Integration Plugins\"
#
# 	You'll find it Workspace > WorkFlow Integration.
# 	This script also highlights an issue with scripting in Resolve. There's no way to lock the user
# 	interface while the script is running and if the user opens a modal window, like Project Settings,
# 	most of the scriptable operations will fail. What's even worse, if the automatic backup kicks in when
# 	a script is running, the script will also fail.
#
# 	Many functions in the Resolve API can return a status so you can check if it succeeded or not, but I
# 	think what we really need is a way to lock the GUI and for backups to be postponed while running. Just
# 	like what happens when you're rendering a file.
#
#
# Added features
# - Rename stills with metadata from clip scene/shot/take/camera or if not available clip name, but
# only if  "Use labels on still export" is checked in Resolve's gallery still album.
#
# - Resize exported stills to a percentage of the original size and resize timeline if resize is more than 100 percent.
#
# - Grab stills only between in and out points.
#
# - Remove drx files generated by Resolve.
#
# - Export stills to a folder with the same name as the timeline.
#
# - Compress exported images with ImageOptim if installed.
#
# 	roger.magnusson@gmail.com
#   bry.randell@gmail.com
#   thomas.briant@gmail.com
#   olivier.patron@gmail.com



import os
import subprocess
import sys
import json


try:
    from PIL import Image, ImageDraw, ImageFont
    print("Pillow is already installed.")
except ImportError:
    print("Pillow not found. Installing...")
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'Pillow'])

    try:
        from PIL import Image, ImageDraw, ImageFont
        print("Pillow has been successfully installed.")
    except ImportError:
        print("Failed to install Pillow.")


class SMPTE(object):
    # Converts frames to SMPTE timecode of arbitrary frame rate and back.
    # Copyright 2021, Igor Riđanović, Igor@hdhead.com, Meta Fide
    '''Frames to SMPTE timecode converter and reverse.'''

    def __init__(self):
        self.fps = 24
        self.df = False

    def getframes(self, tc):
        '''Converts SMPTE timecode to frame count.'''

        if int(tc[9:]) > self.fps:
            raise ValueError('SMPTE timecode to frame rate mismatch.', tc, self.fps)

        hours = int(tc[:2])
        minutes = int(tc[3:5])
        seconds = int(tc[6:8])
        frames = int(tc[9:])

        totalMinutes = int(60 * hours + minutes)

        # Drop frame calculation using the Duncan/Heidelberger method.
        if self.df:

            dropFrames = int(round(self.fps * 0.066666))
            timeBase = int(round(self.fps))

            hourFrames = int(timeBase * 60 * 60)
            minuteFrames = int(timeBase * 60)

            frm = int(((hourFrames * hours) + (minuteFrames * minutes) + (timeBase * seconds) + frames) - (
                        dropFrames * (totalMinutes - (totalMinutes // 10))))

        # Non drop frame calculation.
        else:

            self.fps = int(round(self.fps))
            frm = int((totalMinutes * 60 + seconds) * self.fps + frames)

        return frm

    def gettc(self, frames):
        '''Converts frame count to SMPTE timecode.'''

        frames = abs(frames)

        # Drop frame calculation using the Duncan/Heidelberger method.
        if self.df:

            spacer = ':'
            spacer2 = ':'

            dropFrames = int(round(self.fps * .066666))
            framesPerHour = int(round(self.fps * 3600))
            framesPer24Hours = framesPerHour * 24
            framesPer10Minutes = int(round(self.fps * 600))
            framesPerMinute = int(round(self.fps) * 60 - dropFrames)

            frames = frames % framesPer24Hours

            d = frames // framesPer10Minutes
            m = frames % framesPer10Minutes

            if m > dropFrames:
                frames = frames + (dropFrames * 9 * d) + dropFrames * ((m - dropFrames) // framesPerMinute)

            else:
                frames = frames + dropFrames * 9 * d

            frRound = int(round(self.fps))
            hr = int(frames // frRound // 60 // 60)
            mn = int((frames // frRound // 60) % 60)
            sc = int((frames // frRound) % 60)
            fr = int(frames % frRound)

        # Non drop frame calculation.
        else:

            self.fps = int(round(self.fps))
            spacer = ':'
            spacer2 = spacer

            frHour = self.fps * 3600
            frMin = self.fps * 60

            hr = int(frames // frHour)
            mn = int((frames - hr * frHour) // frMin)
            sc = int((frames - hr * frHour - mn * frMin) // self.fps)
            fr = int(round(frames - hr * frHour - mn * frMin - sc * self.fps))

        # Return SMPTE timecode string.
        return (
                str(hr).zfill(2) + spacer +
                str(mn).zfill(2) + spacer +
                str(sc).zfill(2) + spacer2 +
                str(fr).zfill(2)
        )


def detect_system_and_image_optim_installed(app_name = "ImageOptim"):
    if sys.platform == "darwin":
        return os.path.exists(f'/Applications/{app_name}.app')
    else:
        return False


def load_settings_from_json(settings: dict,
                            setting_sub_folder_name: str = "Stills_Marker_python_settings",
                            setting_file_name: str = "settings.json"):

    # return the folder from where the script is running
    script_path = os.path.dirname(os.path.abspath(sys.argv[0]))
    setting_path_folder = os.path.join(script_path, setting_sub_folder_name)
    if not os.path.exists(setting_path_folder):
        os.mkdir(setting_path_folder)

    setting_path = os.path.join(setting_path_folder, setting_file_name)

    # print("script path {}".format(script_path))

    try:
        with open(setting_path) as j:
            json_settings = json.load(j)
        print(f"loaded settings from {setting_path}")
        if set(json_settings.keys()) == set(settings.keys()):
            return json_settings
        else:
            print("settings.json file is not valid")
            with open(setting_path, "w") as j:
                json.dump(settings, j)
            print(f"created a {setting_path} setting file")
            return settings
    except:
        print("cannot find setting file")
        with open(setting_path, "w") as j:
            json.dump(settings, j)
        print(f"created a {setting_path} setting file")
        return settings


def save_settings_to_json(settings: dict,
                            setting_sub_folder_name: str = "Stills_Marker_python_settings",
                            setting_file_name: str = "settings.json"):
    # very weak path handling
    try:
        script_path = os.path.dirname(os.path.abspath(sys.argv[0]))
        setting_path_folder = os.path.join(script_path, setting_sub_folder_name)
        setting_path = os.path.join(setting_path_folder, setting_file_name)

        with open(setting_path, "w") as j:
            json.dump(settings, j)
    except:
        print("cannot find setting file")


def reselect_album(album, gallery):
    for gallery_album in gallery.GetGalleryStillAlbums():
        if gallery_album != album:
            gallery.SetCurrentStillAlbum(gallery_album)
            break
    gallery.SetCurrentStillAlbum(album)
    return album


def change_page(page):
    current_page = resolve.GetCurrentPage()

    def get_state():
        current_state = {
            'page': current_page,
            'project': resolve.GetProjectManager().GetCurrentProject()
        }

        if current_state['project']:
            current_state['timeline'] = current_state['project'].GetCurrentTimeline()

            if current_state['timeline']:
                current_state['timecode'] = current_state['timeline'].GetCurrentTimecode()

        return current_state

    if current_page in ["media", "fusion"]:
        assert resolve.OpenPage(page), f"Couldn't open page: {page}"
        state = get_state()
    else:
        state = get_state()
        assert resolve.OpenPage(page), f"Couldn't open page: {page}"

    return state


def restore_page(state):
    def set_state(initial_state):
        current_project = resolve.GetProjectManager().GetCurrentProject()

        if current_project:
            current_timeline = current_project.GetCurrentTimeline()

            if current_timeline and current_timeline == initial_state['timeline'] and initial_state['timecode']:
                initial_state['timeline'].SetCurrentTimecode(initial_state['timecode'])

    current_page = resolve.GetCurrentPage()

    if current_page in ["media", "fusion"]:
        resolve.OpenPage(state['page'])
        set_state(state)
    else:
        set_state(state)
        resolve.OpenPage(state['page'])


def timecode_from_frame(frame, frame_rate, drop_frame):
    smpte = SMPTE()
    smpte.fps = frame_rate
    smpte.df = drop_frame
    return smpte.gettc(frame)


def frame_from_timecode(timecode, frame_rate, drop_frame):
    smpte = SMPTE()
    smpte.fps = frame_rate
    smpte.df = drop_frame
    return smpte.getframes(timecode)


def create_new_filename(clip):
    """
    Only for US formated Scene/Shot/take slate
    does not work with double letter camera name
    :param clip:
    :return:
    """
    letters = ("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "O", "P", "Q", "R", "S", "T", "U",
               "V", "W", "X", "Y", "Z", " ")
    if clip.GetMediaPoolItem().GetClipProperty()['Scene']:
        scene = clip.GetMediaPoolItem().GetClipProperty()['Scene'][:3]
        if any(letter in clip.GetMediaPoolItem().GetClipProperty()['Scene'] for letter in letters):
            shot = clip.GetMediaPoolItem().GetClipProperty()['Scene'][3:]
            if clip.GetMediaPoolItem().GetClipProperty()['Take']:
                take = clip.GetMediaPoolItem().GetClipProperty()['Take'][1:]
                if clip.GetName()[0] in letters:
                    # see if i will implement alexa35 naming convention with double letter for camera
                    camera = clip.GetName()[0]
                    return "{}{}_T{}_CAM{}_".format(scene, shot, take, camera)
                else:
                    return "{}{}_T{}_".format(scene, shot, take)
            else:
                if clip.GetName()[0] in letters:
                    camera = clip.GetName()[0]
                    return "{}{}_CAM{}_".format(scene, shot, camera)
                else:
                    return "{}{}_".format(scene, shot)
        else:
            if clip.GetMediaPoolItem().GetClipProperty()['Take']:
                take = clip.GetMediaPoolItem().GetClipProperty()['Take'][1:]
                if clip.GetName()[0] in letters:
                    camera = clip.GetName()[0]
                    return "{}_T{}_CAM{}_".format(scene, take, camera)
                else:
                    return "{}_T{}_".format(scene, take)
            else:
                if clip.GetName()[0] in letters:
                    camera = clip.GetName()[0]
                    return "{}_CAM{}_".format(scene, camera)
                else:
                    return "{}_".format(scene)
    else:
        # print("No scene found returning clip name")
        return clip.GetName().split('.')[0] + "_"


def resize_image(input_path, percentage, delete_original, original_size=None):
    """
    Resizes the image to the specified size and optionally deletes the original image.

    :param input_path: Path to the input image.
    :param percentage: Percentage of the original size.
    :param delete_original: If True, the original image will be deleted after resizing.
    """
    if percentage > 1 and percentage < 100:

        with Image.open(input_path) as img:
            # Calculate new dimensions
            new_width = int(img.width * percentage / 100)
            new_height = int(img.height * percentage / 100)

            resized_img = img.resize((new_width, new_height), Image.LANCZOS)
            if delete_original:
                resized_img.save(input_path)
            else:
                # print("entering the else statement for delete original")
                input_path_split, extension = os.path.splitext(input_path)
                output_path = f"{input_path_split}_resized{extension}"
                resized_img.save(output_path)
                # print(f"output path {output_path} - input path {input_path}")
    else:
        if original_size and not delete_original:
            # print(f"original size {original_size}")
            with Image.open(input_path) as img:
                resized_img = img.resize((original_size[0], original_size[1]), Image.LANCZOS)
                input_path_split, extension = os.path.splitext(input_path)
                output_path = f"{input_path_split}_original_size{extension}"
                resized_img.save(output_path)
                # print(f"output path {output_path} - input path {input_path}")
        else:
            print("bypass downsizing, percentage must be between 1 and 100.")


def get_all_mediapool_bins(parent_bin):
    """
    Recursively gets all the bins in the mediapool
    :param parent_bin: davinci bin object
    :return: list of all the dvr object bins in mediapool project, problem is it returns multiple times the same bin
    """
    bins_list = [bin for bin in parent_bin.GetSubFolderList()]
    for sub_bin in bins_list:
        bins_list.extend(get_all_mediapool_bins(sub_bin))
    return bins_list

def find_in_out_points_of_timeline_in_folder(root_folder, timeline):
    # doesn't return if it won't find the timeline or the in and out points
    bins_list = get_all_mediapool_bins(root_folder)
    bins_list.extend([root_folder])

    for bin in bins_list:
        # print(f"bin --- {bin.GetName()}")
        for item in bin.GetClipList():
            if item.GetClipProperty()['Type'] == 'Timeline' and item.GetName() == timeline.GetName():
                markIn = item.GetClipProperty("In") or item.GetClipProperty("Start TC")
                markOut = item.GetClipProperty("Out") or item.GetClipProperty("End TC")
                return markIn, markOut
    return "", ""


def detect_in_out_point_timeline(project, timeline):
    """
    Detects the in and out point of the timeline
    Coded by Olivier Patron
    :param timeline:
    :return:
    """
    # search for timeline in root folder
    root_folder = project.GetMediaPool().GetRootFolder()
    markIn, markOut = find_in_out_points_of_timeline_in_folder(root_folder, timeline)
    print(f"found in {timeline} - markin {markIn} - markout {markOut}")
    return markIn, markOut


def get_marker_count_by_color(markers):
    marker_count_by_color = {"Any": 0}
    for _, marker in markers.items():
        if marker["color"] not in marker_count_by_color:
            marker_count_by_color[marker["color"]] = 0
        marker_count_by_color[marker["color"]] += 1
        marker_count_by_color["Any"] += 1
        # print(f"function output {marker_count_by_color}")
    return marker_count_by_color

def get_timeline_project_resolution(project, timeline):
    return (int(timeline.GetSetting('timelineResolutionWidth')),
            int(timeline.GetSetting('timelineResolutionHeight')),
            int(project.GetSetting('timelineResolutionWidth')),
            int(project.GetSetting('timelineResolutionHeight')))

def timeline_resolution_override(project, timeline, resolution_tuple, resolution_percentage):
    """
    Overrides the timeline resolution by a percentage
    :param project:
    :param timeline:
    :param resolution_percentage:
    :return: tuple of bool for success
    """
    res_t_width, res_t_height, res_p_width, res_p_height = resolution_tuple
    res_timeline_width = res_t_width * (int(resolution_percentage)/100)
    res_timeline_height = res_t_height * (int(resolution_percentage)/100)
    res_project_width = res_p_width * (int(resolution_percentage)/100)
    res_project_height = res_p_height * (int(resolution_percentage)/100)
    # print(f"res_timeline_width {res_timeline_width} res_timeline_height {res_timeline_height} res_project_width {res_project_width} res_project_height {res_project_height}")
    return (timeline.SetSetting('timelineResolutionWidth', str(int(res_timeline_width))),
            timeline.SetSetting('timelineResolutionHeight', str(int(res_timeline_height))),
            project.SetSetting('timelineResolutionWidth', str(int(res_project_width))),
            project.SetSetting('timelineResolutionHeight', str(int(res_project_height))))


stills = {
    "formats": {
        "dpx": "DPX Files (*.dpx)",
        "cin": "Cineon Files (*.cin)",
        "tif": "TIFF Files (*.tif)",
        "jpg": "JPEG Files (*.jpg)",
        "png": "PNG Files (*.png)",
        "ppm": "PPM Files (*.ppm)",
        "bmp": "BMP Files (*.bmp)",
        "xpm": "XPM Files (*.xpm)",
        "sort_order": ["dpx", "cin", "tif", "jpg", "png", "ppm", "bmp", "xpm"]
    },
    "reselect_album": reselect_album,
}

markers_dict = {
    "get_marker_count_by_color": get_marker_count_by_color,
    "colors": [
        "Blue", "Cyan", "Green", "Yellow", "Red", "Pink", "Purple", "Fuchsia",
        "Rose", "Lavender", "Sky", "Mint", "Lemon", "Sand", "Cocoa", "Cream"
    ]
}

dict_settings = {"markers": "Any",
                  "export": True,
                  "export_to": "",
                  "format": "jpg",
                  "resize_stills": False,
                  "resize_percentage": 50,
                  "replace_original_exports": True,
                  "rename_with_meta": "clip_name",
                 "restrict_to_in_out": True,
                 "remove_drx": True,
                 "create_export_folder_timeline_name": True,
                 "create_sub_folder": True,
                 "sub_folder_name": "Stills",
                 "compress": False}


settings = load_settings_from_json(dict_settings)
# print(settings)
ui = fusion.UIManager
dispatcher = bmd.UIDispatcher(ui)


def create_window(marker_count_by_color, markers, still_album_name, timeline_settings):
    # some element ID
    winID = "com.blackmagicdesign.resolve.stills_marker"
    win_name = "Stills Marker"
    marker_combo_boxID = "MarkersComboBox"
    info_labelID = "InfoLabel"
    export_check_boxID = "ExportCheckBox"
    restrict_to_in_out_check_boxID = "RestrictToInOutCheckBox"
    remove_drx_check_boxID = "RemoveDrxCheckBox"
    create_timeline_folder_check_boxID = "CreateTimelineFolderCheckBox"
    sub_folder_groupID = "SubFolderGroup"
    create_sub_folder_check_boxID = "CreateSubFolderCheckBox"
    sub_folder_name_line_editID = "SubFolderNameLineEdit"
    export_settingsID = "ExportSettings"
    export_to_line_editID = "ExportToLineEdit"
    resize_check_boxID = "ResizeCheckBox"
    resize_settingsID = "ResizeSettings"
    resize_replace_check_boxID = "ResizeReplaceCheckBox"
    resize_line_editID = "ResizeLineEdit"
    rename_with_meta_check_boxID = "RenameWithMetaCheckBox"
    browse_buttonID = "BrowseButton"
    format_combo_boxID = "FormatComboBox"
    compress_setting_boxID = "CompressSettings"
    compress_check_boxID = "CompressCheckBox"
    # burnin_check_boxID = "BurninCheckBox"
    # burnin_settings_buttonID = "BurninSettingsButton"
    cancel_buttonID = "CancelButton"
    start_buttonID = "StartButton"

    # check for existing instance
    main_window = ui.FindWindow(winID)
    if main_window:
        main_window.Show()
        main_window.Raise()
        exit()

    left_column_minimum_size = {100, 0}
    left_column_maximum_size = {100, 16777215}

    if sys.platform == "win32":
        window_flags = {
            "Window": True,
            "CustomizeWindowHint": True,
            "WindowCloseButtonHint": True
        }
    else:
        window_flags = {
            "Dialog": True,
        }

    # Assuming 'dispatcher' and 'script' are predefined in your context
    main_window = dispatcher.AddWindow(
        {
            'ID': winID,
            'WindowTitle': win_name,
            'WindowFlags': window_flags,
            'WindowModality': "ApplicationModal",
            'FixedSize': [500, 380],
            'Events': {'Close': True,
                       'KeyPress': True}
        },
        ui.VGroup(
            {
                'MinimumSize': [450, 300],
                'MaximumSize': [16777215, 350],
                'Weight': 1
            },
            [
                ui.HGroup(# group for marker management
                    {
                        'Weight': 0,
                        'Spacing': 10
                    }, [
                        ui.Label(
                            {
                                'Weight': 0,
                                'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                'MinimumSize': left_column_minimum_size,
                                'MaximumSize': left_column_maximum_size,
                                'Text': "Timeline markers"
                            }
                        ),
                        ui.ComboBox(
                            {
                                'Weight': 1,
                                'ID': marker_combo_boxID
                            }
                        ),
                    ]
                ),
                ui.HGroup(
                    {
                        'Weight': 0,
                        'Spacing': 10
                    }, [
                        ui.Label(
                            {
                                'Weight': 0,
                                'MinimumSize': left_column_minimum_size,
                                'MaximumSize': left_column_maximum_size
                            }
                        ),
                        ui.Label(
                            {
                                'Weight': 1,
                                'ID': info_labelID
                            }
                        ),
                    ]
                ),
                ui.VGap(10),
                ui.HGroup(# group to enable export and export settings
                    {
                        'Weight': 0,
                        'Spacing': 10
                    },
                    [
                        ui.Label(
                            {
                                'Weight': 0,
                                'MinimumSize': left_column_minimum_size,
                                'MaximumSize': left_column_maximum_size
                            }
                        ),
                        ui.CheckBox(
                            {
                                'Weight': 1,
                                'ID': export_check_boxID,
                                'Text': "Export grabbed stills",
                                'Checked': settings["export"],
                                'Events': {'Toggled': True}
                            }
                        ),
                    ]
                ),
                ui.VGroup(
                    {
                        'ID': export_settingsID,
                        'Weight': 0,
                        'Enabled': settings["export"]
                    },
                    [
                        ui.HGroup( # check box group restrict in/out, remove drx and rename with meta
                            {
                                'Weight': 0,
                                'Spacing': 10
                            }, [
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size,
                                        'Text': "Restrict to in/out"
                                    }
                                ),
                                ui.CheckBox(
                                    {
                                        'Weight': 0,
                                        'ID': restrict_to_in_out_check_boxID,
                                        'Text': "Restrict to in/out point",
                                        'Checked': settings["restrict_to_in_out"],
                                        'Events': {'Toggled': True}
                                    }
                                ),
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size,
                                        'Text': "Remove DRX"
                                    }
                                ),
                                ui.CheckBox(
                                    {
                                        'Weight': 0,
                                        'ID': remove_drx_check_boxID,
                                        'Text': "Remove DRX files",
                                        'Checked': settings["remove_drx"],
                                        'Events': {'Toggled': True}
                                    }
                                ),
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size,
                                        'Text': "Create sub folder"
                                    }
                                ),
                                ui.CheckBox(
                                    {
                                        'Weight': 0,
                                        'ID': rename_with_meta_check_boxID,
                                        'Text': "Rename with meta",
                                        'Checked': settings["rename_with_meta"],
                                        'Events': {'Toggled': True}
                                    }
                                ),

                            ]
                        ),
                        ui.HGroup(  # group to create sub folder
                            {
                                'Weight': 0,
                                'Spacing': 10
                            }, [
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size
                                    }
                                ),
                                ui.CheckBox(
                                    {
                                        'Weight': 1,
                                        'ID': create_timeline_folder_check_boxID,
                                        'Text': "Create Folder with timeline name",
                                        'Checked': settings["create_export_folder_timeline_name"],
                                        'Events': {'Toggled': True}
                                    }
                                ),
                            ]
                        ),
                        ui.HGroup( # group for sub folder
                            {   'ID' : sub_folder_groupID,
                                'Weight': 0,
                                'Spacing': 10,
                                'Enabled': settings["create_export_folder_timeline_name"]
                            }, [
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size,
                                        'Text': "Create sub folder"
                                    }
                                ),
                                ui.CheckBox(
                                    {
                                        'Weight': 0,
                                        'ID': create_sub_folder_check_boxID,
                                        'Text': "Create sub folder with name :",
                                        'Checked': settings["create_sub_folder"],
                                        'Events': {'Toggled': True}
                                    }
                                ),
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size,
                                        'Text': "Sub folder name:"
                                    }
                                ),
                                ui.LineEdit(
                                    {
                                        'Weight': 1,
                                        'ID': sub_folder_name_line_editID,
                                        'Text': settings["sub_folder_name"]
                                    }
                                ),
                            ]
                        ),

                        ui.HGroup(# group for export to line edit
                            {
                                'Weight': 0,
                                'Spacing': 10
                            },
                            [
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size,
                                        'Text': "Export to"
                                    }
                                ),
                                ui.LineEdit(
                                    {
                                        'Weight': 1,
                                        'ID': export_to_line_editID,
                                        'Text': settings["export_to"]
                                    }
                                ),
                                ui.Button(
                                    {
                                        'Weight': 0,
                                        'ID': browse_buttonID,
                                        'Text': "Browse",
                                        'AutoDefault': False
                                    }
                                ),
                            ]),
                        ui.HGroup(# group for combo box format image choice
                            {
                            'Weight': 0,
                            'Spacing': 10
                            },
                            [
                            ui.Label({
                                'Weight': 0,
                                'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                'MinimumSize': left_column_minimum_size,
                                'MaximumSize': left_column_maximum_size,
                                'Text': "Format"
                            }),
                            ui.ComboBox({
                                'Weight': 1,
                                'ID': format_combo_boxID
                            })
                        ]),
                        ui.HGroup(# group for resize check box
                            {
                                'Weight': 0,
                                'Spacing': 10,
                            },
                            [
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size,
                                    }
                                ),
                                ui.CheckBox(
                                    {
                                        'Weight': 0,
                                        'ID': resize_check_boxID,
                                        'Text': "Resize stills in %",
                                        'Checked': settings["resize_stills"],
                                        'Events': {'Toggled': True}
                                    }
                                ),
                            ]
                        ),
                        ui.VGroup(
                            # group for resize settings
                            {"ID": resize_settingsID,
                             "Weight": 0,
                             "Enabled": settings["resize_stills"]
                             },
                            [
                                ui.HGroup(
                                    {
                                        'Weight': 0,
                                        'Spacing': 10
                                    }, [
                                        ui.Label(
                                            {
                                                'Weight': 0,
                                                'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                                'MinimumSize': left_column_minimum_size,
                                                'MaximumSize': left_column_maximum_size,
                                                'Text': "Resize to"
                                            }
                                        ),
                                        ui.LineEdit(
                                            {
                                                'Weight': 1,
                                                'ID': resize_line_editID,
                                                'Text': str(settings["resize_percentage"])
                                            }
                                        ),
                                        ui.Label(
                                            {
                                                'Weight': 1,
                                                'Alignment': {'AlignRight': True, 'AlignVCenter': True},
                                                'MinimumSize': left_column_minimum_size,
                                                'MaximumSize': left_column_maximum_size,
                                                'Text': "%"
                                            }
                                        ),
                                        ui.CheckBox(
                                            {
                                                'Weight': 0,
                                                'ID': resize_replace_check_boxID,
                                                'Text': "Replace original exports",
                                                'Checked': settings["replace_original_exports"],
                                                'Events': {'Toggled': True}
                                            }
                                        ),
                                    ]
                                ),
                            ]
                        ),
                        ui.VGap(0, 1),
                        ui.HGroup(# group for compress check box
                            {
                                'ID': compress_setting_boxID,
                                'Weight': 0,
                                'Spacing': 10,
                                "Enabled": settings["format"] == "jpg"
                            },
                            [
                                ui.Label(
                                    {
                                        'Weight': 0,
                                        'MinimumSize': left_column_minimum_size,
                                        'MaximumSize': left_column_maximum_size,
                                    }
                                ),
                                ui.CheckBox(
                                    {
                                        'Weight': 0,
                                        'ID': compress_check_boxID,
                                        'Text': "Compress JPEG with ImageOptim",
                                        'Checked': settings["compress"],
                                        'Events': {'Toggled': True}
                                    }
                                ),
                            ]
                        ),
                    ]
                ),
                ui.HGroup({  # group for cancel and start button
                    'Weight': 0,
                    'Spacing': 10,
                    'StyleSheet': '''
                                    QPushButton
                                    {
                                        min-height: 22px;
                                        max-height: 22px;
                                        min-width: 108px;
                                        max-width: 108px;
                                    }
                                '''
                }, [
                    ui.HGap(0, 1),
                    ui.Button({
                        'Weight': 0,
                        'ID': cancel_buttonID,
                        'Text': "Cancel",
                        'AutoDefault': False
                    }),
                    ui.Button({
                        'Weight': 0,
                        'ID': start_buttonID,
                        'Text': "Start",
                        'AutoDefault': False,
                        'Default': True
                    })
                ])
            ]
        )
    )
    window_items = main_window.GetItems()

    def update_controls():
        # print('entering updates')
        marker_count_by_color = markers_dict["get_marker_count_by_color"](
            markers if not settings["restrict_to_in_out"] else markers_in_out)
        start_button_enabled = not window_items[export_check_boxID].Checked or \
                               (window_items[export_check_boxID].Checked and \
                                len(window_items[export_to_line_editID].Text) > 0)
        # Enable/disable controls based on the state of other controls
        window_items[export_settingsID].Enabled = window_items[export_check_boxID].Checked
        window_items[resize_settingsID].Enabled = window_items[resize_check_boxID].Checked
        window_items[create_sub_folder_check_boxID].Enabled = window_items[create_timeline_folder_check_boxID].Checked
        # settings["create_sub_folder"] = window_items[create_sub_folder_check_boxID].Checked
        window_items[sub_folder_groupID].Enabled = window_items[create_timeline_folder_check_boxID].Checked

        compress_enabled = settings["format"] == "jpg" and detect_system_and_image_optim_installed()
        window_items[compress_setting_boxID].Enabled = compress_enabled
        marker_count = marker_count_by_color.get(window_items[marker_combo_boxID].CurrentText)

        if marker_count is not None and marker_count > 0:
            marker_plural = "" if marker_count == 1 else "s"
            window_items[info_labelID].Text = f"{marker_count} still{marker_plural} will be grabbed to the \"{still_album_name}\" album"
        else:
            marker_color = "" if window_items[marker_combo_boxID].CurrentText == "Any" \
                else window_items[marker_combo_boxID].CurrentText.lower() + " "
            window_items[info_labelID].Text = f"No {marker_color}markers found, no stills will be grabbed"
            start_button_enabled = False
        # print(window_items[info_labelID].Text)

        window_items[start_buttonID].Enabled = start_button_enabled
        window_items[export_to_line_editID].ToolTip = window_items[export_to_line_editID].Text

    def initialize_controls():
        right_column_button_width = 70  # excluding border

        # Example of setting style sheet
        main_window.StyleSheet = f"""
            QComboBox
            {{
                margin-right: {right_column_button_width + 2 + 10}px;
                padding-right: 6px;
                padding-left: 6px;
                min-height: 18px;
                max-height: 18px;
            }}
    
            QLineEdit
            {{
                padding-top: 0px;
                margin-top: 1px;
                min-height: 18px;
                max-height: 18px;
            }}
    
            QPushButton
            {{
                min-height: 20px;
                max-height: 20px;
                min-width: {right_column_button_width}px;
                max-width: {right_column_button_width}px;
            }}
        """

        window_items[marker_combo_boxID].AddItem("Any")
        window_items[marker_combo_boxID].AddItems(markers_dict["colors"])
        window_items[marker_combo_boxID].InsertSeparator(1)
        window_items[marker_combo_boxID].CurrentText = settings["markers"]

        for format in stills["formats"]["sort_order"]:
            window_items[format_combo_boxID].AddItem(stills["formats"][format])

        window_items[format_combo_boxID].CurrentText = stills["formats"][settings["format"]]

        update_controls()

    # Call initialize_controls
    initialize_controls()

    # Event handlers
    def OnGenericCheckBoxToggled(ev):
        update_controls()

    def OnMarkersComboBoxCurrentIndexChanged(ev):
        update_controls()

    def OnRestrictToInOutCheckBoxToggled(ev):
        settings["restrict_to_in_out"] = window_items[restrict_to_in_out_check_boxID].Checked
        update_controls()

    def OnResizeLineEditTextChanged(ev):
        update_controls()

    def OnFormatComboBoxCurrentIndexChanged(ev):
        settings["format"] = stills["formats"]["sort_order"][window_items[format_combo_boxID].CurrentIndex]
        # print(settings["format"])
        update_controls()

    def OnBrowseButtonClicked(ev):
        selectedDir = fusion.RequestDir(window_items[export_to_line_editID].Text, {"FReqS_Title": "Export to"})
        if selectedDir:
            window_items[export_to_line_editID].Text = selectedDir
        update_controls()

    def OnExportToLineEditTextChanged(ev):
        update_controls()

    def OnCancelButtonClicked(ev):
        dispatcher.ExitLoop(False)

    def OnStartButtonClicked(ev):
        # Add your logic for what happens when the Start button is clicked
        settings["markers"] = window_items[marker_combo_boxID].CurrentText
        settings["export"] = window_items[export_check_boxID].Checked
        settings["export_to"] = window_items[export_to_line_editID].Text
        # maybe +1 to skip the "Any" item
        settings["format"] = stills["formats"]["sort_order"][window_items[format_combo_boxID].CurrentIndex]
        settings["resize_stills"] = window_items[resize_check_boxID].Checked
        settings["resize_percentage"] = window_items[resize_line_editID].Text
        settings["replace_original_exports"] = window_items[resize_replace_check_boxID].Checked
        settings["rename_with_meta"] = window_items[rename_with_meta_check_boxID].Checked
        settings["restrict_to_in_out"] = window_items[restrict_to_in_out_check_boxID].Checked
        settings["remove_drx"] = window_items[remove_drx_check_boxID].Checked
        settings["create_export_folder_timeline_name"] = window_items[create_timeline_folder_check_boxID].Checked
        settings["create_sub_folder"] = window_items[create_sub_folder_check_boxID].Checked
        settings["sub_folder_name"] = window_items[sub_folder_name_line_editID].Text
        settings["compress"] = window_items[compress_check_boxID].Checked
        save_settings_to_json(settings)
        dispatcher.ExitLoop(True)


    def OnWindowKeyPress(ev):
        # print(ev["Key"])
        # Add your logic for key press events
        if ev["Key"] == 16777220:
            OnStartButtonClicked(ev)
        if ev["Key"] == 16777216:
            dispatcher.ExitLoop(False)

    def OnClose(ev):
        dispatcher.ExitLoop()

    # Assigning event handlers
    main_window.On[marker_combo_boxID].CurrentIndexChanged = OnMarkersComboBoxCurrentIndexChanged
    main_window.On[export_check_boxID].Toggled = OnGenericCheckBoxToggled
    main_window.On[restrict_to_in_out_check_boxID].Toggled = OnRestrictToInOutCheckBoxToggled
    main_window.On[remove_drx_check_boxID].Toggled = OnGenericCheckBoxToggled
    main_window.On[create_timeline_folder_check_boxID].Toggled = OnGenericCheckBoxToggled
    main_window.On[create_sub_folder_check_boxID].Toggled = OnGenericCheckBoxToggled
    main_window.On[browse_buttonID].Clicked = OnBrowseButtonClicked
    main_window.On[export_to_line_editID].TextChanged = OnExportToLineEditTextChanged
    main_window.On[resize_check_boxID].Toggled = OnGenericCheckBoxToggled
    main_window.On[resize_replace_check_boxID].Toggled = OnGenericCheckBoxToggled
    main_window.On[resize_line_editID].TextChanged = OnResizeLineEditTextChanged
    main_window.On[rename_with_meta_check_boxID].Toggled = OnGenericCheckBoxToggled
    main_window.On[format_combo_boxID].CurrentIndexChanged = OnFormatComboBoxCurrentIndexChanged
    main_window.On[cancel_buttonID].Clicked = OnCancelButtonClicked
    main_window.On[start_buttonID].Clicked = OnStartButtonClicked
    main_window.On[winID].KeyPress = OnWindowKeyPress
    # main_window.On[winID].KeyPress = OnWindowKeyPressEnter
    main_window.On[winID].Close = OnClose

    return main_window


# Main dispatcher loop
project = resolve.GetProjectManager().GetCurrentProject()
assert project, "Couldn't get current project"
gallery = project.GetGallery()
assert gallery, "Couldn't get the Resolve stills gallery"
still_album = gallery.GetCurrentStillAlbum()
assert still_album, "Couldn't get the current gallery still album"
still_album_name = gallery.GetAlbumName(still_album)
timeline = project.GetCurrentTimeline()
assert timeline, "Couldn't get current timeline"

timeline_start = timeline.GetStartFrame()
frame_rate = timeline.GetSetting("timelineFrameRate")
drop_frame = int(timeline.GetSetting("timelineDropFrameTimecode"))
# print(drop_frame, type(drop_frame))
# print(timeline_start, frame_rate, drop_frame)
markIn, markOut = detect_in_out_point_timeline(project, timeline)
markIn_frame = frame_from_timecode(markIn, frame_rate, drop_frame)
markOut_frame = frame_from_timecode(markOut, frame_rate, drop_frame)
resolution_tuple = get_timeline_project_resolution(project, timeline)
timeline_settings = {
    "timeline_start": timeline_start,
    "frame_rate": frame_rate,
    "drop_frame": drop_frame,
    "markIn": markIn,
    "markOut": markOut,
    "markIn_frame": markIn_frame,
    "markOut_frame": markOut_frame
}
markers = timeline.GetMarkers()
# launch the script if it finds markers
if markers:  # Equivalent to `if next(markers) ~= nil` in Lua
    marker_frames = sorted(markers.keys())
    # making a copy of markers to delete markers outside of in and out points
    markers_in_out = markers.copy()
    marker_to_delete = []
    # calulcate markers outside of in and out points
    for marker_frame in marker_frames:
        marker_offset_frame = timeline_start + marker_frame
        # print(f"marker offset frame {marker_offset_frame} - markin frame {markIn_frame} - markout frame {markOut_frame}")
        if marker_offset_frame < markIn_frame or marker_offset_frame > markOut_frame:
            marker_to_delete.append(marker_frame)
    # delete markers outside of in and out points
    print(f"delete {len(marker_to_delete)} marker outside of in out points")
    for marker_frame in marker_to_delete:
        del markers_in_out[marker_frame]
    # launching the ui
    marker_count_by_color = markers_dict["get_marker_count_by_color"](markers if not settings["restrict_to_in_out"] else markers_in_out)
    window = create_window(marker_count_by_color, markers, still_album_name, timeline_settings)
    window.Show()
    grab_stills = dispatcher.RunLoop()
    window.Hide()
    print("launching script main loop and grab_stills is ", grab_stills)

    # start button pushed
    if grab_stills:
        initial_state = change_page("color")
        stills_to_export = []
        # Create a list to contain ordered marker frames
        print(f"found {len(marker_frames)} markers")
        if settings["resize_stills"] and int(settings["resize_percentage"]) > 100 and settings["export"]:
            tres, tres2, pres, pres2 = timeline_resolution_override(project, timeline, resolution_tuple, settings["resize_percentage"])
            print(f"timeline resolution override {tres} {tres2} {pres} {pres2}")
        # Process the markers in order and loop through them to grab stills
        for marker_frame in marker_frames:
            marker = markers.get(marker_frame) if not settings["restrict_to_in_out"] else markers_in_out.get(marker_frame)
            if marker:
                # discriminate markers by color
                if settings["markers"] == "Any" or settings["markers"] == marker["color"]:
                    marker_offset_frame = timeline_start + marker_frame
                    timecode = timecode_from_frame(marker_offset_frame, frame_rate, drop_frame)
                    grabbed_still = None  # Initialize grabbed_still to None
                    assert timeline.SetCurrentTimecode(timecode), f"Couldn't navigate to marker at {timecode}"
                    grabbed_still = timeline.GrabStill()
                    if not grabbed_still:
                        raise Exception(f"Couldn't grab still at {timecode}")

                    if grabbed_still is not None:
                        stills_to_export.append(grabbed_still)
                        # rename stills with metadata if it finds scene, take and camera otherwise use clip name
                        if settings["rename_with_meta"]:
                            still_album.SetLabel(grabbed_still, create_new_filename(timeline.GetCurrentVideoItem()))

        # export stills to image files
        if settings["export"]:
            prefix = ""
            if settings["create_export_folder_timeline_name"]:
                sub_folder = f"{timeline.GetName()}".replace(" ", "_")
                output_path_timeline = os.path.join(settings["export_to"], sub_folder)
                if not os.path.exists(output_path_timeline):
                    os.makedirs(output_path_timeline)
                if settings["create_sub_folder"]:
                    subfolder_name = settings["sub_folder_name"]
                    output_path = os.path.join(output_path_timeline, subfolder_name.replace(" ", "_"))
                    if not os.path.exists(output_path):
                        os.makedirs(output_path)
                else:
                    output_path = output_path_timeline
            else:
                output_path = settings["export_to"]
            reselect_album(still_album, gallery)
            assert still_album.ExportStills(stills_to_export, output_path, prefix,
                                            settings["format"]), "An error occurred while exporting stills"

            # resize stills
            if settings["resize_stills"]:
                images = [os.path.join(output_path, image) for image in os.listdir(output_path)\
                          if image.endswith(settings["format"])]
                for image in images:
                    resize_image(image, int(settings["resize_percentage"]), settings["replace_original_exports"])
                if int(settings["resize_percentage"]) > 100:
                    tres, tres2, pres, pres2 = timeline_resolution_override(project, timeline, resolution_tuple, 100)
                    for image in images:
                        # use a dummy resize percentage at 100 to bypass downsizing
                        resize_image(image, 100, settings["replace_original_exports"], original_size=resolution_tuple[:2])

            # remove drx files
            if settings["remove_drx"]:
                drx_files = [os.path.join(output_path, drx_file) for drx_file in os.listdir(output_path) \
                             if drx_file.endswith(".drx")]
                for drx_file in drx_files:
                    os.remove(drx_file)

            # compress images with ImageOptim only for jpg and if ImageOptim is installed
            if settings["compress"]:
                if detect_system_and_image_optim_installed():
                    try:
                        imageoptim_command = f"open -a ImageOptim {output_path}/*.jpg"
                        subprocess.run(imageoptim_command, shell=True)
                    except:
                        print("Couldn't open ImageOptim.app")
                        print("Make sure ImageOptim.app is installed and try again.")
                        print("https://imageoptim.com/ImageOptim.tbz2")
                else:
                    print("Couldn't find ImageOptim.app in applications folder")
                    print("Make sure ImageOptim.app is installed and try again.")
                    print("https://imageoptim.com/ImageOptim.tbz2")

        restore_page(initial_state)
